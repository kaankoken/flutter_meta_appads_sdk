// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: log_standard_event_message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum FBStandardEvents: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case adClick // = 0
  case adImpression // = 1
  case completedRegistration // = 2
  case completedTutorial // = 3
  case contact // = 4
  case customizeProduct // = 5
  case donate // = 6
  case findLocation // = 7
  case rated // = 8
  case schedule // = 9
  case searched // = 10
  case startTrial // = 11
  case submitApplication // = 12
  case subscribe // = 13
  case viewedContent // = 14
  case addedPaymentInfo // = 15
  case addedToCart // = 16
  case addedToWishlist // = 17
  case initiatedCheckout // = 18
  case purchased // = 19
  case achievedLevel // = 20
  case unlockedAchievement // = 21
  case spentCredits // = 22
  case UNRECOGNIZED(Int)

  init() {
    self = .adClick
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .adClick
    case 1: self = .adImpression
    case 2: self = .completedRegistration
    case 3: self = .completedTutorial
    case 4: self = .contact
    case 5: self = .customizeProduct
    case 6: self = .donate
    case 7: self = .findLocation
    case 8: self = .rated
    case 9: self = .schedule
    case 10: self = .searched
    case 11: self = .startTrial
    case 12: self = .submitApplication
    case 13: self = .subscribe
    case 14: self = .viewedContent
    case 15: self = .addedPaymentInfo
    case 16: self = .addedToCart
    case 17: self = .addedToWishlist
    case 18: self = .initiatedCheckout
    case 19: self = .purchased
    case 20: self = .achievedLevel
    case 21: self = .unlockedAchievement
    case 22: self = .spentCredits
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .adClick: return 0
    case .adImpression: return 1
    case .completedRegistration: return 2
    case .completedTutorial: return 3
    case .contact: return 4
    case .customizeProduct: return 5
    case .donate: return 6
    case .findLocation: return 7
    case .rated: return 8
    case .schedule: return 9
    case .searched: return 10
    case .startTrial: return 11
    case .submitApplication: return 12
    case .subscribe: return 13
    case .viewedContent: return 14
    case .addedPaymentInfo: return 15
    case .addedToCart: return 16
    case .addedToWishlist: return 17
    case .initiatedCheckout: return 18
    case .purchased: return 19
    case .achievedLevel: return 20
    case .unlockedAchievement: return 21
    case .spentCredits: return 22
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [FBStandardEvents] = [
    .adClick,
    .adImpression,
    .completedRegistration,
    .completedTutorial,
    .contact,
    .customizeProduct,
    .donate,
    .findLocation,
    .rated,
    .schedule,
    .searched,
    .startTrial,
    .submitApplication,
    .subscribe,
    .viewedContent,
    .addedPaymentInfo,
    .addedToCart,
    .addedToWishlist,
    .initiatedCheckout,
    .purchased,
    .achievedLevel,
    .unlockedAchievement,
    .spentCredits,
  ]

}

enum FBStandardParameters: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case parameterNameContent // = 0
  case parameterNameContentID // = 1
  case parameterNameContentType // = 2
  case parameterNameCurrency // = 3
  case parameterNameDescription // = 4
  case parameterNameLevel // = 5
  case parameterNameMaxRatingValue // = 6
  case parameterNameNumItems // = 7
  case parameterNamePaymentInfoAvailable // = 8
  case parameterNameRegistrationMethod // = 9
  case parameterNameSearchString // = 10
  case parameterNameSuccess // = 11
  case parameterNameAdType // = 12
  case parameterNameOrderID // = 13
  case parameterNameEventName // = 14
  case parameterNameLogTime // = 15
  case UNRECOGNIZED(Int)

  init() {
    self = .parameterNameContent
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .parameterNameContent
    case 1: self = .parameterNameContentID
    case 2: self = .parameterNameContentType
    case 3: self = .parameterNameCurrency
    case 4: self = .parameterNameDescription
    case 5: self = .parameterNameLevel
    case 6: self = .parameterNameMaxRatingValue
    case 7: self = .parameterNameNumItems
    case 8: self = .parameterNamePaymentInfoAvailable
    case 9: self = .parameterNameRegistrationMethod
    case 10: self = .parameterNameSearchString
    case 11: self = .parameterNameSuccess
    case 12: self = .parameterNameAdType
    case 13: self = .parameterNameOrderID
    case 14: self = .parameterNameEventName
    case 15: self = .parameterNameLogTime
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .parameterNameContent: return 0
    case .parameterNameContentID: return 1
    case .parameterNameContentType: return 2
    case .parameterNameCurrency: return 3
    case .parameterNameDescription: return 4
    case .parameterNameLevel: return 5
    case .parameterNameMaxRatingValue: return 6
    case .parameterNameNumItems: return 7
    case .parameterNamePaymentInfoAvailable: return 8
    case .parameterNameRegistrationMethod: return 9
    case .parameterNameSearchString: return 10
    case .parameterNameSuccess: return 11
    case .parameterNameAdType: return 12
    case .parameterNameOrderID: return 13
    case .parameterNameEventName: return 14
    case .parameterNameLogTime: return 15
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [FBStandardParameters] = [
    .parameterNameContent,
    .parameterNameContentID,
    .parameterNameContentType,
    .parameterNameCurrency,
    .parameterNameDescription,
    .parameterNameLevel,
    .parameterNameMaxRatingValue,
    .parameterNameNumItems,
    .parameterNamePaymentInfoAvailable,
    .parameterNameRegistrationMethod,
    .parameterNameSearchString,
    .parameterNameSuccess,
    .parameterNameAdType,
    .parameterNameOrderID,
    .parameterNameEventName,
    .parameterNameLogTime,
  ]

}

struct FBLogStandardEventMessageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventName: FBStandardEvents = .adClick

  var eventParameter: [FBDefaultParameter] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FBDefaultParameter: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parameterName: FBStandardParameters = .parameterNameContent

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension FBStandardEvents: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AdClick"),
    1: .same(proto: "AdImpression"),
    2: .same(proto: "CompletedRegistration"),
    3: .same(proto: "CompletedTutorial"),
    4: .same(proto: "Contact"),
    5: .same(proto: "CustomizeProduct"),
    6: .same(proto: "Donate"),
    7: .same(proto: "FindLocation"),
    8: .same(proto: "Rated"),
    9: .same(proto: "Schedule"),
    10: .same(proto: "Searched"),
    11: .same(proto: "StartTrial"),
    12: .same(proto: "SubmitApplication"),
    13: .same(proto: "Subscribe"),
    14: .same(proto: "ViewedContent"),
    15: .same(proto: "AddedPaymentInfo"),
    16: .same(proto: "AddedToCart"),
    17: .same(proto: "AddedToWishlist"),
    18: .same(proto: "InitiatedCheckout"),
    19: .same(proto: "Purchased"),
    20: .same(proto: "AchievedLevel"),
    21: .same(proto: "UnlockedAchievement"),
    22: .same(proto: "SpentCredits"),
  ]
}

extension FBStandardParameters: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ParameterNameContent"),
    1: .same(proto: "ParameterNameContentID"),
    2: .same(proto: "ParameterNameContentType"),
    3: .same(proto: "ParameterNameCurrency"),
    4: .same(proto: "ParameterNameDescription"),
    5: .same(proto: "ParameterNameLevel"),
    6: .same(proto: "ParameterNameMaxRatingValue"),
    7: .same(proto: "ParameterNameNumItems"),
    8: .same(proto: "ParameterNamePaymentInfoAvailable"),
    9: .same(proto: "ParameterNameRegistrationMethod"),
    10: .same(proto: "ParameterNameSearchString"),
    11: .same(proto: "ParameterNameSuccess"),
    12: .same(proto: "ParameterNameAdType"),
    13: .same(proto: "ParameterNameOrderID"),
    14: .same(proto: "ParameterNameEventName"),
    15: .same(proto: "ParameterNameLogTime"),
  ]
}

extension FBLogStandardEventMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FBLogStandardEventMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eventName"),
    2: .same(proto: "eventParameter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.eventName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.eventParameter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventName != .adClick {
      try visitor.visitSingularEnumField(value: self.eventName, fieldNumber: 1)
    }
    if !self.eventParameter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.eventParameter, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FBLogStandardEventMessageRequest, rhs: FBLogStandardEventMessageRequest) -> Bool {
    if lhs.eventName != rhs.eventName {return false}
    if lhs.eventParameter != rhs.eventParameter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FBDefaultParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FBDefaultParameter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameterName"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.parameterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.parameterName != .parameterNameContent {
      try visitor.visitSingularEnumField(value: self.parameterName, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FBDefaultParameter, rhs: FBDefaultParameter) -> Bool {
    if lhs.parameterName != rhs.parameterName {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
